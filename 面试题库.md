## 事务的隔离级别
包括四种：Read uncommitted<Read committed<Repeatable read<Serializable
### Read uncommitted
读未提交，一个事务可以读取另一个未提交事务的数据,会产生脏读
### Read committed
读提交，就是一个事务要等另一个事务提交后才能读取数据
若有事务对数据进行更新(update)操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但会出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读
若有事务对数据进行插入(insert)操作，会出现幻读
### Repeatable read
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
重复读可以解决不可重复读问题
### Serializable
事务串行化顺序执行，可以避免脏读、不可重复读与幻读。隔离级别效率低下，比较耗数据库性能，一般不使用。
### 数据库修改事务隔离级别
```
#mysql
#可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE
#mysql默认是REPEATABLE-READ
transaction-isolation = REPEATABLE-READ
```
## MySQL 主从复制的原理
从库生成两个线程，一个I/O线程，一个SQL线程；
i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；
主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；
SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；

## MySQL 主从同步延时问题
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。
### semi-sync(半同步复制)
解决主库数据丢失问题
主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了
### 并行复制
解决主从同步延时问题
从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行
## 脏读
如果一个事务中对数据进行了更新，但**事务还没有提交**，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据
## 幻读
幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的
## 写入数据时，聚簇索引所在的列的内容是随机的，会引起什么性能问题
聚簇索引情况下，写入数据时，插入速度严重依赖插入顺序，按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。   
基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。   
聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
## COW机制
```
var_dump(memory_get_usage()); // int(660240)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(697192)   
$b = $a;
var_dump(memory_get_usage()); // int(697192)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(734112)
```
**值相同共享内存的策略——写时复制**
如果通过赋值的方式赋值给变量时不会申请新内存来存放新变量所保存的值，而是简单的通过一个计数器来共用内存，只有在其中的一个引用指向变量的 值发生变化时才申请新空间来保存值内容以减少对内存的占用。 在很多场景下，PHP 都使用了 COW 进行内存的优化，比如：变量的多次赋值、函数参数传递，并在函数体内修改实参等