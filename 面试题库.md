## 事务的隔离级别
包括四种：Read uncommitted<Read committed<Repeatable read<Serializable
### Read uncommitted
读未提交，一个事务可以读取另一个未提交事务的数据,会产生脏读
### Read committed
读提交，就是一个事务要等另一个事务提交后才能读取数据
若有事务对数据进行更新(update)操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但会出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读
若有事务对数据进行插入(insert)操作，会出现幻读
### Repeatable read
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
重复读可以解决不可重复读问题
### Serializable
事务串行化顺序执行，可以避免脏读、不可重复读与幻读。隔离级别效率低下，比较耗数据库性能，一般不使用。
### 数据库修改事务隔离级别
```
#mysql
#可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE
#mysql默认是REPEATABLE-READ
transaction-isolation = REPEATABLE-READ
```
## MySQL 主从复制的原理
从库生成两个线程，一个I/O线程，一个SQL线程；
i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；
主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；
SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；

## MySQL 主从同步延时问题
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。
### semi-sync(半同步复制)
解决主库数据丢失问题
主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了
### 并行复制
解决主从同步延时问题
从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行
## 脏读
如果一个事务中对数据进行了更新，但**事务还没有提交**，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据
## 幻读
幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的